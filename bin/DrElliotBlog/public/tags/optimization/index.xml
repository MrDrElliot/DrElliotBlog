<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Optimization on Dr. Elliot</title>
    <link>https://www.dr-elliot.com/tags/optimization/</link>
    <description>Recent content in Optimization on Dr. Elliot</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 29 Sep 2024 12:28:45 -0500</lastBuildDate>
    <atom:link href="https://www.dr-elliot.com/tags/optimization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Move Semantics</title>
      <link>https://www.dr-elliot.com/posts/memory/movesemantics/</link>
      <pubDate>Sun, 29 Sep 2024 12:28:45 -0500</pubDate>
      <guid>https://www.dr-elliot.com/posts/memory/movesemantics/</guid>
      <description>Hello! Today, I want to talk about a commonly misunderstood concept in programming: Move Semantics.&#xA;Move semantics involve efficiently transferring ownership of resources (like memory) from one object to another, instead of copying the data, which adds unnecessary overhead. This is especially important in performance-critical applications such as game development, where proper memory management can make a big difference in efficiency. Games, just like any other software, are prone to performance pitfalls caused by poor handling of move semantics.</description>
    </item>
    <item>
      <title>The Cast Scare</title>
      <link>https://www.dr-elliot.com/posts/optimization/thecastscare/</link>
      <pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://www.dr-elliot.com/posts/optimization/thecastscare/</guid>
      <description>Hello! Today I wanted to talk a little bit about casting, primarily Blueprint casting. The main reason I wanted to bring this up is because it&amp;rsquo;s one of the most misunderstood and blown-out-of-proportion concepts in Unreal Engine. There&amp;rsquo;s no shortage of YouTube videos with clickbait titles like &amp;ldquo;Casting is so bad, NEVER use it in your games!&amp;rdquo; (or some variation of that). This highlights a larger problem: people creating tutorials when they have no business doing so.</description>
    </item>
    <item>
      <title>What Are Soft References?</title>
      <link>https://www.dr-elliot.com/posts/memory/softreferences/</link>
      <pubDate>Fri, 16 Aug 2024 14:31:08 -0500</pubDate>
      <guid>https://www.dr-elliot.com/posts/memory/softreferences/</guid>
      <description>What Are Soft References? Soft references are a way to reference an object in Unreal Engine without forcing it to stay in memory. This can be incredibly useful in scenarios where you need to reference assets like textures, sounds, or even entire levels, but donâ€™t want to load them into memory until absolutely necessary.&#xA;Why Use Soft References? Imagine your game has a massive library of assets. Loading everything at once would quickly consume your memory, leading to performance issues or, worse, crashing your game.</description>
    </item>
    <item>
      <title>Constexpr and Consteval</title>
      <link>https://www.dr-elliot.com/posts/general/constexpr/</link>
      <pubDate>Fri, 16 Aug 2024 13:46:48 -0500</pubDate>
      <guid>https://www.dr-elliot.com/posts/general/constexpr/</guid>
      <description>Simple way to possibly increase some performance. This blog is a follow-up to this YouTube video: https://www.youtube.com/watch?v=8-VZoXn8f9U&#xA;Consider the following code:&#xA;// ConstexprExample.cpp : This file contains the &amp;#39;main&amp;#39; function. Program execution begins and ends there. // #include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; int Fibonacci(int n) { if (n &amp;lt;= 1) return n; return Fibonacci(n - 1) + Fibonacci(n - 2); } constexpr int Fibonacci_C(int n) { if (n &amp;lt;= 1) return n; return Fibonacci_C(n - 1) + Fibonacci_C(n - 2); } int main() { auto Start = std::chrono::high_resolution_clock::now(); constexpr int num = 25; constexpr int result_c = Fibonacci_C(num); std::cout &amp;lt;&amp;lt; &amp;#34;Constexpr Fibonacci: &amp;#34; &amp;lt;&amp;lt; result_c &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;; std::cout &amp;lt;&amp;lt; &amp;#34;Time Taken: &amp;#34; &amp;lt;&amp;lt; std::chrono::duration_cast&amp;lt;std::chrono::microseconds&amp;gt;(std::chrono::high_resolution_clock::now() - Start).</description>
    </item>
  </channel>
</rss>
