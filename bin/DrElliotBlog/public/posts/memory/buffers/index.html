<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Working With Buffers | Dr. Elliot</title>
<link rel="icon" href="/favicon.svg" sizes="any" type="image/svg+xml" /><meta property="og:url" content="https://www.dr-elliot.com/posts/memory/buffers/">
  <meta property="og:site_name" content="Dr. Elliot">
  <meta property="og:title" content="Working With Buffers">
  <meta property="og:description" content="Buffers are simply containers of bytes that can store raw data using memory offsets. Understanding how to effectively manage these buffers is essential for tasks like serialization, deserialization, and data storage.
Raw C&#43;&#43; Buffer Management In raw C&#43;&#43;, managing buffers and packing data requires manual handling of memory offsets. For example, consider the following code that packs several uint32_t values into a std::vector&lt;std::byte&gt; buffer:
#include &lt;vector&gt; #include &lt;cstdint&gt; #include &lt;cstring&gt; // For std::memcpy void PackData() { // Buffer to hold the packed data std::vector&lt;std::byte&gt; buffer; // Example data std::vector&lt;uint32_t&gt; data = { 1234, 5678, 91011 }; // Calculate the total size needed for the buffer size_t totalSize = data.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-08-16T12:28:45-05:00">
    <meta property="article:modified_time" content="2024-08-16T12:28:45-05:00">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="UnrealEngine">
    <meta property="article:tag" content="CPP">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Working With Buffers">
  <meta name="twitter:description" content="Buffers are simply containers of bytes that can store raw data using memory offsets. Understanding how to effectively manage these buffers is essential for tasks like serialization, deserialization, and data storage.
Raw C&#43;&#43; Buffer Management In raw C&#43;&#43;, managing buffers and packing data requires manual handling of memory offsets. For example, consider the following code that packs several uint32_t values into a std::vector&lt;std::byte&gt; buffer:
#include &lt;vector&gt; #include &lt;cstdint&gt; #include &lt;cstring&gt; // For std::memcpy void PackData() { // Buffer to hold the packed data std::vector&lt;std::byte&gt; buffer; // Example data std::vector&lt;uint32_t&gt; data = { 1234, 5678, 91011 }; // Calculate the total size needed for the buffer size_t totalSize = data.">

      <link rel="stylesheet" href="/css/root.min.0e732b812b9751962e01a7c4798a1211cd5f8ac8abec7f99793fe306989e459f.css" integrity="sha256-DnMrgSuXUZYuAafEeYoSEc1fisir7H&#43;ZeT/jBpieRZ8=" crossorigin="anonymous">
      <link rel="stylesheet" href="/css/bundle.min.59eb1a059f8cd558e64375ede3e68d3e9120ddb0c6bdbab555c247689cef59e1.css" integrity="sha256-WesaBZ&#43;M1VjmQ3Xt4&#43;aNPpEg3bDGvbq1VcJHaJzvWeE=" crossorigin="anonymous">

      <script src="/js/bundle.cc8ae9952dbfb731affafabdf26e5c60a6910047ff59ccdeaf1daebaa26c8830.js" integrity="sha256-zIrplS2/tzGv&#43;vq98m5cYKaRAEf/Wczerx2uuqJsiDA=" crossorigin="anonymous"></script><script defer src="/js/search/flexsearch.compact.5e0de3b335e5c523c7cf45473dc43fccb6c75f64a9d59cc04a6eccbb7c25eb49.js" integrity="sha256-Xg3jszXlxSPHz0VHPcQ/zLbHX2Sp1ZzASm7Mu3wl60k="></script>
<script defer src="/js/search/search.1d980f84df11f3eb7c8c5f17f541d49a0611608df179dd74fa7f06225eb56ace.js" integrity="sha256-HZgPhN8R8&#43;t8jF8X9UHUmgYRYI3xed10&#43;n8GIl61as4="></script>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&family=Spectral:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;1,200;1,300;1,400;1,500;1,600;1,700;1,800&display=swap" rel="stylesheet">

</head>
<body class="notransition">
  <div id="container">
    <header id="main-header"><div role="navigation" aria-label="Main">
  <div class="nav-left">
    <a href="https://www.dr-elliot.com/" style="color: inherit;">Dr. Elliot</a>
  </div>
  <div class="nav-right">
    <div style="position:absolute;width:0px;height:0px;">
      <div id="nav-dropdown-menu" class="hidden" href="#">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/lumina/lumina/"
      >Lumina</a>
    </div>
    <div class="nav-item">
      <a href="/about/aboutme/"
      >About</a>
    </div>
</div>
    </div>
    <a id="nav-dropdown-button" href="#"><svg width="20px" height="20px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M4 6H20M4 12H20M4 18H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
    <div id="nav-menu">
    <div class="nav-item">
      <a aria-current="true" class="ancestor" href="/posts/"
      >Posts</a>
    </div>
    <div class="nav-item">
      <a href="/lumina/lumina/"
      >Lumina</a>
    </div>
    <div class="nav-item">
      <a href="/about/aboutme/"
      >About</a>
    </div>
</div>
    <a id="theme-switcher" href="#">
<svg class="light-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M12 3V4M12 20V21M4 12H3M6.31412 6.31412L5.5 5.5M17.6859 6.31412L18.5 5.5M6.31412 17.69L5.5 18.5001M17.6859 17.69L18.5 18.5001M21 12H20M16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>

<svg class="dark-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M3.32031 11.6835C3.32031 16.6541 7.34975 20.6835 12.3203 20.6835C16.1075 20.6835 19.3483 18.3443 20.6768 15.032C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834C12.3497 15.6834 8.32031 11.654 8.32031 6.68342C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996C5.65605 4.66028 3.32031 7.89912 3.32031 11.6835Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
</svg>
</a>
  </div>
</div>
</header>
    <div class="flex grow">
      <div id="main-pane">
        <main id="main-content"><div class="single-header">
<ol class="breadcrumbs" itemscope itemtype="https://schema.org/BreadcrumbList">
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://www.dr-elliot.com/">
        <span itemprop="name">Home</span>
      </a>
      <meta itemprop="position" content='1' />
    </li>
    <span>&nbsp»&nbsp</span>
    <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
      <a itemprop="item" href="https://www.dr-elliot.com/posts/">
        <span itemprop="name">Posts</span>
      </a>
      <meta itemprop="position" content='2' />
    </li>
    <span>&nbsp»&nbsp</span>
</ol>
<h1>Working With Buffers</h1><time class="dim" datetime="2024-08-16T12:28:45-05:00">August 16, 2024</time><div class="term-container"><div class="tag">
        <a href="https://www.dr-elliot.com/tags/c&#43;&#43;/">#C&#43;&#43;</a>
      </div><div class="tag">
        <a href="https://www.dr-elliot.com/tags/unrealengine/">#UnrealEngine</a>
      </div><div class="tag">
        <a href="https://www.dr-elliot.com/tags/cpp/">#CPP</a>
      </div></ol></div>

  <section class="page-section"><p>Buffers are simply containers of bytes that can store raw data using memory offsets. Understanding how to effectively manage these buffers is essential for tasks like serialization, deserialization, and data storage.</p>
<h2 id="raw-c-buffer-management">Raw C++ Buffer Management</h2>
<p>In raw C++, managing buffers and packing data requires manual handling of memory offsets. For example, consider the following code that packs several <code>uint32_t</code> values into a <code>std::vector&lt;std::byte&gt;</code> buffer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdint&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">  </span><span style="color:#75715e">// For std::memcpy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">PackData</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Buffer to hold the packed data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>byte<span style="color:#f92672">&gt;</span> buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Example data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">uint32_t</span><span style="color:#f92672">&gt;</span> data <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1234</span>, <span style="color:#ae81ff">5678</span>, <span style="color:#ae81ff">91011</span> };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Calculate the total size needed for the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t totalSize <span style="color:#f92672">=</span> data.size() <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint32_t</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Resize the buffer to fit the data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    buffer.resize(totalSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Copy each uint32_t into the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (size_t i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> data.size(); <span style="color:#f92672">++</span>i)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Calculate the offset in the buffer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        size_t offset <span style="color:#f92672">=</span> i <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint32_t</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Use std::memcpy to copy the data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>memcpy(buffer.data() <span style="color:#f92672">+</span> offset, <span style="color:#f92672">&amp;</span>data[i], <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">uint32_t</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this example, the buffer is resized to hold the data, and each <code>uint32_t</code> value is copied into the buffer at the appropriate offset.</p>
<h2 id="simplified-buffer-management-in-unreal-engine">Simplified Buffer Management in Unreal Engine</h2>
<p>Unreal Engine simplifies this process with its <code>FMemoryReader</code> and <code>FMemoryWriter</code> classes. These classes handle the serialization and deserialization of data, abstracting away manual memory management.</p>
<h3 id="using-fmemorywriter">Using <strong>FMemoryWriter</strong></h3>
<p>To write data to a buffer, use <code>FMemoryWriter</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Serialization/MemoryWriter.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Containers/Array.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">SerializeData</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    int32 SomeInt <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>;
</span></span><span style="display:flex;"><span>    TArray<span style="color:#f92672">&lt;</span>uint8<span style="color:#f92672">&gt;</span> Buffer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Create a memory writer to serialize data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FMemoryWriter Writer(Buffer, true <span style="color:#75715e">/*bSerializeAsSingleBlock*/</span>);
</span></span><span style="display:flex;"><span>        Writer <span style="color:#f92672">&lt;&lt;</span> SomeInt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="using-fmemoryreader">Using <strong>FMemoryReader</strong></h3>
<p>To read data from a buffer, use <code>FMemoryReader</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Serialization/MemoryReader.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Containers/Array.h&#34;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DeserializeData</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    int32 DeserializedInt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    TArray<span style="color:#f92672">&lt;</span>uint8<span style="color:#f92672">&gt;</span> Buffer; <span style="color:#75715e">// Assume this buffer has been filled with data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Create a memory reader to deserialize data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        FMemoryReader Reader(Buffer, true <span style="color:#75715e">/*bDeserializeAsSingleBlock*/</span>);
</span></span><span style="display:flex;"><span>        Reader <span style="color:#f92672">&lt;&lt;</span> DeserializedInt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="explanation">Explanation</h3>
<ul>
<li><strong><code>FMemoryWriter</code></strong>: Writes data to a <code>TArray&lt;uint8&gt;</code> buffer. The <code>bSerializeAsSingleBlock</code> flag optimizes memory usage by serializing the data in one contiguous block.</li>
<li><strong><code>FMemoryReader</code></strong>: Reads data from a <code>TArray&lt;uint8&gt;</code> buffer. The <code>bDeserializeAsSingleBlock</code> flag optimizes memory access during deserialization.</li>
</ul>
<p>These classes simplify the process of packing and unpacking data, allowing you to focus on higher-level functionality without worrying about manual offset calculations.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Whether you&rsquo;re working with raw C++ or leveraging Unreal Engine&rsquo;s built-in classes, managing buffers and memory efficiently is crucial for effective data handling. Unreal Engine&rsquo;s <code>FMemoryReader</code> and <code>FMemoryWriter</code> provide powerful abstractions that streamline these processes, making your development workflow smoother and more robust.</p>
<hr>
</section>

  <section id="comments">
    <script src="https://utteranc.es/client.js"
        repo="MrDrElliot/DrElliotBlog"
        issue-term="pathname"
        theme="github-dark"
        crossorigin="anonymous"
        async>
    </script>
</section>
</main>
        <footer id="main-footer"><div class="footer">
  <a href="#">Scroll to Top</a>
  <div class="footer-copyright">
    <div class="dim">© 2025 Dr. Elliot</div>
    <div>Made with ❤️ and powered by <a href="https://github.com/math-queiroz/rusty-typewriter" target="_blank">Rusty Typewriter</a> theme for <a href="https://gohugo.io/" target="_blank">Hugo</a></div>
  </div>
</div>
</footer>
      </div><aside id="side-pane" class="side-sticky"><div class="side-details">
    <span>414 words</span>
    <span>3 - 3 minutes read</span></div><h3>Table Of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#raw-c-buffer-management">Raw C++ Buffer Management</a></li>
    <li><a href="#simplified-buffer-management-in-unreal-engine">Simplified Buffer Management in Unreal Engine</a>
      <ul>
        <li><a href="#using-fmemorywriter">Using <strong>FMemoryWriter</strong></a></li>
        <li><a href="#using-fmemoryreader">Using <strong>FMemoryReader</strong></a></li>
        <li><a href="#explanation">Explanation</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav><h3>Related</h3>
    <ul><li><a href="/posts/networking/networkserialization/">Network Serialization</a></li></ul></aside></div>
  </div>
</body>
</html>
